// Package bitly provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package bitly

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/pkg/errors"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// BadRequest defines model for BadRequest.
type BadRequest struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// BaseMetrics defines model for BaseMetrics.
type BaseMetrics struct {
	Facet         *string `json:"facet,omitempty"`
	Unit          *string `json:"unit,omitempty"`
	UnitReference *string `json:"unit_reference,omitempty"`
	Units         *int    `json:"units,omitempty"`
}

// BitlinkBody defines model for BitlinkBody.
type BitlinkBody struct {
	// Embedded struct due to allOf(#/components/schemas/HasReferences)
	HasReferences `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/BitlinkUpdate)
	BitlinkUpdate `yaml:",inline"`
}

// BitlinkQR defines model for BitlinkQR.
type BitlinkQR struct {
	Id   *string `json:"id,omitempty"`
	Link *string `json:"link,omitempty"`

	// Data URI of QR Code image
	QrCode *string `json:"qr_code,omitempty"`
}

// BitlinkUpdate defines model for BitlinkUpdate.
type BitlinkUpdate struct {
	Archived       *bool           `json:"archived,omitempty"`
	ClientId       *string         `json:"client_id,omitempty"`
	CreatedAt      *string         `json:"created_at,omitempty"`
	CreatedBy      *string         `json:"created_by,omitempty"`
	CustomBitlinks *[]string       `json:"custom_bitlinks,omitempty"`
	Deeplinks      *[]DeeplinkRule `json:"deeplinks,omitempty"`
	Id             *string         `json:"id,omitempty"`
	Link           *string         `json:"link,omitempty"`
	LongUrl        *string         `json:"long_url,omitempty"`
	Tags           *[]string       `json:"tags,omitempty"`
	Title          *string         `json:"title,omitempty"`
}

// Bitlinks defines model for Bitlinks.
type Bitlinks struct {
	Links      *[]BitlinkBody `json:"links,omitempty"`
	Pagination *Pagination    `json:"pagination,omitempty"`
}

// CityMetric defines model for CityMetric.
type CityMetric struct {
	City      *string `json:"city,omitempty"`
	Clicks    *int    `json:"clicks,omitempty"`
	Country   *string `json:"country,omitempty"`
	Region    *string `json:"region,omitempty"`
	Subregion *string `json:"subregion,omitempty"`
}

// CityMetrics defines model for CityMetrics.
type CityMetrics struct {
	// Embedded struct due to allOf(#/components/schemas/BaseMetrics)
	BaseMetrics `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Metrics      *[]CityMetric `json:"metrics,omitempty"`
	OtherMetrics *OtherMetrics `json:"other_metrics,omitempty"`
}

// ClickLink defines model for ClickLink.
type ClickLink struct {
	Clicks *int    `json:"clicks,omitempty"`
	Id     *string `json:"id,omitempty"`
}

// ClickMetric defines model for ClickMetric.
type ClickMetric struct {
	Clicks *int    `json:"clicks,omitempty"`
	Value  *string `json:"value,omitempty"`
}

// ClickMetrics defines model for ClickMetrics.
type ClickMetrics struct {
	// Embedded struct due to allOf(#/components/schemas/BaseMetrics)
	BaseMetrics `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Metrics *[]ClickMetric `json:"metrics,omitempty"`
}

// Clicks defines model for Clicks.
type Clicks struct {
	LinkClicks    *[]LinkClicks `json:"link_clicks,omitempty"`
	Unit          *string       `json:"unit,omitempty"`
	UnitReference *string       `json:"unit_reference,omitempty"`
	Units         *int          `json:"units,omitempty"`
}

// ClicksSummary defines model for ClicksSummary.
type ClicksSummary struct {
	TotalClicks   *int    `json:"total_clicks,omitempty"`
	Unit          *string `json:"unit,omitempty"`
	UnitReference *string `json:"unit_reference,omitempty"`
	Units         *int    `json:"units,omitempty"`
}

// Deeplink defines model for Deeplink.
type Deeplink struct {
	AppId       *string `json:"app_id,omitempty"`
	AppUriPath  *string `json:"app_uri_path,omitempty"`
	InstallType *string `json:"install_type,omitempty"`
	InstallUrl  *string `json:"install_url,omitempty"`
}

// DeeplinkRule defines model for DeeplinkRule.
type DeeplinkRule struct {
	AppGuid    *string `json:"app_guid,omitempty"`
	AppUriPath *string `json:"app_uri_path,omitempty"`
	Bitlink    *string `json:"bitlink,omitempty"`
	BrandGuid  *string `json:"brand_guid,omitempty"`

	// ISO timestamp
	Created     *string `json:"created,omitempty"`
	Guid        *string `json:"guid,omitempty"`
	InstallType *string `json:"install_type,omitempty"`
	InstallUrl  *string `json:"install_url,omitempty"`

	// ISO timestamp
	Modified *string `json:"modified,omitempty"`
	Os       *string `json:"os,omitempty"`
}

// DeviceMetric defines model for DeviceMetric.
type DeviceMetric struct {
	Clicks     *int    `json:"clicks,omitempty"`
	DeviceType *string `json:"device_type,omitempty"`
}

// DeviceMetrics defines model for DeviceMetrics.
type DeviceMetrics struct {
	// Embedded struct due to allOf(#/components/schemas/BaseMetrics)
	BaseMetrics `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Metrics *[]DeviceMetric `json:"metrics,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Description *string       `json:"description,omitempty"`
	Errors      *[]FieldError `json:"errors,omitempty"`
	Message     *string       `json:"message,omitempty"`
	Resource    *string       `json:"resource,omitempty"`
}

// ExpandBitlink defines model for ExpandBitlink.
type ExpandBitlink struct {
	BitlinkId *string `json:"bitlink_id,omitempty"`
}

// ExpandedBitlink defines model for ExpandedBitlink.
type ExpandedBitlink struct {
	CreatedAt *string `json:"created_at,omitempty"`
	Id        *string `json:"id,omitempty"`
	Link      *string `json:"link,omitempty"`
	LongUrl   *string `json:"long_url,omitempty"`
}

// ExpectationFailed defines model for ExpectationFailed.
type ExpectationFailed struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// FieldError defines model for FieldError.
type FieldError struct {
	ErrorCode *string `json:"error_code,omitempty"`
	Field     *string `json:"field,omitempty"`
	Message   *string `json:"message,omitempty"`
}

// Forbidden defines model for Forbidden.
type Forbidden struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// FullShorten defines model for FullShorten.
type FullShorten struct {
	Deeplinks *[]Deeplink `json:"deeplinks,omitempty"`
	Domain    *string     `json:"domain,omitempty"`

	// Always include a specific group and custom domain in your shorten calls.
	GroupGuid *string   `json:"group_guid,omitempty"`
	LongUrl   string    `json:"long_url"`
	Tags      *[]string `json:"tags,omitempty"`
	Title     *string   `json:"title,omitempty"`
}

// HasReferences defines model for HasReferences.
type HasReferences struct {
	References *HasReferences_References `json:"references,omitempty"`
}

// HasReferences_References defines model for HasReferences.References.
type HasReferences_References struct {
	AdditionalProperties map[string]string `json:"-"`
}

// InternalError defines model for InternalError.
type InternalError struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// LinkClicks defines model for LinkClicks.
type LinkClicks struct {
	Clicks *int    `json:"clicks,omitempty"`
	Date   *string `json:"date,omitempty"`
}

// Metric defines model for Metric.
type Metric struct {
	Key   *string `json:"key,omitempty"`
	Value *int    `json:"value,omitempty"`
}

// NotFound defines model for NotFound.
type NotFound struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// OtherMetrics defines model for OtherMetrics.
type OtherMetrics struct {
	NoCityClicks    *int `json:"no_city_clicks,omitempty"`
	OtherCityClicks *int `json:"other_city_clicks,omitempty"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	Next  *string `json:"next,omitempty"`
	Page  *int    `json:"page,omitempty"`
	Prev  *string `json:"prev,omitempty"`
	Size  *int    `json:"size,omitempty"`
	Total *int    `json:"total,omitempty"`
}

// ReferrersByDomain defines model for ReferrersByDomain.
type ReferrersByDomain struct {
	Network   *string   `json:"network,omitempty"`
	Referrers *[]Metric `json:"referrers,omitempty"`
}

// ReferrersByDomains defines model for ReferrersByDomains.
type ReferrersByDomains struct {
	Facet             *string              `json:"facet,omitempty"`
	ReferrersByDomain *[]ReferrersByDomain `json:"referrers_by_domain,omitempty"`
	Unit              *string              `json:"unit,omitempty"`
	UnitReference     *string              `json:"unit_reference,omitempty"`
	Units             *int                 `json:"units,omitempty"`
}

// Shorten defines model for Shorten.
type Shorten struct {
	Domain    *string `json:"domain,omitempty"`
	GroupGuid *string `json:"group_guid,omitempty"`
	LongUrl   string  `json:"long_url"`
}

// ShortenBitlinkBody defines model for ShortenBitlinkBody.
type ShortenBitlinkBody struct {
	// Embedded struct due to allOf(#/components/schemas/HasReferences)
	HasReferences `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Archived       *bool           `json:"archived,omitempty"`
	CreatedAt      *string         `json:"created_at,omitempty"`
	CustomBitlinks *[]string       `json:"custom_bitlinks,omitempty"`
	Deeplinks      *[]DeeplinkRule `json:"deeplinks,omitempty"`
	Id             *string         `json:"id,omitempty"`
	Link           *string         `json:"link,omitempty"`
	LongUrl        *string         `json:"long_url,omitempty"`
	Tags           *[]string       `json:"tags,omitempty"`
}

// SortedLinks defines model for SortedLinks.
type SortedLinks struct {
	Links       *[]BitlinkBody `json:"links,omitempty"`
	SortedLinks *[]ClickLink   `json:"sorted_links,omitempty"`
}

// TemporarilyUnavailable defines model for TemporarilyUnavailable.
type TemporarilyUnavailable struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// UpgradeRequired defines model for UpgradeRequired.
type UpgradeRequired struct {
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// Archived defines model for Archived.
type Archived string

// List of Archived
const (
	Archived_both Archived = "both"
	Archived_off  Archived = "off"
	Archived_on   Archived = "on"
)

// Bitlink defines model for Bitlink.
type Bitlink string

// Color defines model for Color.
type Color string

// CreatedAfter defines model for CreatedAfter.
type CreatedAfter int

// CreatedBefore defines model for CreatedBefore.
type CreatedBefore int

// Deeplinks defines model for Deeplinks.
type Deeplinks string

// List of Deeplinks
const (
	Deeplinks_both Deeplinks = "both"
	Deeplinks_off  Deeplinks = "off"
	Deeplinks_on   Deeplinks = "on"
)

// DomainDeeplinks defines model for DomainDeeplinks.
type DomainDeeplinks string

// List of DomainDeeplinks
const (
	DomainDeeplinks_both DomainDeeplinks = "both"
	DomainDeeplinks_off  DomainDeeplinks = "off"
	DomainDeeplinks_on   DomainDeeplinks = "on"
)

// EncodingLogin defines model for EncodingLogin.
type EncodingLogin []string

// ExcludeBitlyLogo defines model for ExcludeBitlyLogo.
type ExcludeBitlyLogo bool

// FilterCampaignGUID defines model for FilterCampaignGUID.
type FilterCampaignGUID string

// FilterChannelGUID defines model for FilterChannelGUID.
type FilterChannelGUID string

// FilterCustomBitlink defines model for FilterCustomBitlink.
type FilterCustomBitlink string

// List of FilterCustomBitlink
const (
	FilterCustomBitlink_both FilterCustomBitlink = "both"
	FilterCustomBitlink_off  FilterCustomBitlink = "off"
	FilterCustomBitlink_on   FilterCustomBitlink = "on"
)

// GroupGUID defines model for GroupGUID.
type GroupGUID string

// ImageFormat defines model for ImageFormat.
type ImageFormat string

// List of ImageFormat
const (
	ImageFormat_png ImageFormat = "png"
	ImageFormat_svg ImageFormat = "svg"
)

// Keyword defines model for Keyword.
type Keyword string

// ModifiedAfter defines model for ModifiedAfter.
type ModifiedAfter int

// Page defines model for Page.
type Page int

// Query defines model for Query.
type Query string

// Size defines model for Size.
type Size int

// Sort defines model for Sort.
type Sort string

// List of Sort
const (
	Sort_clicks Sort = "clicks"
)

// Tags defines model for Tags.
type Tags []string

// TimeUnit defines model for TimeUnit.
type TimeUnit string

// List of TimeUnit
const (
	TimeUnit_day    TimeUnit = "day"
	TimeUnit_hour   TimeUnit = "hour"
	TimeUnit_minute TimeUnit = "minute"
	TimeUnit_month  TimeUnit = "month"
	TimeUnit_week   TimeUnit = "week"
)

// TimeUnitOptional defines model for TimeUnitOptional.
type TimeUnitOptional string

// List of TimeUnitOptional
const (
	TimeUnitOptional_day    TimeUnitOptional = "day"
	TimeUnitOptional_hour   TimeUnitOptional = "hour"
	TimeUnitOptional_minute TimeUnitOptional = "minute"
	TimeUnitOptional_month  TimeUnitOptional = "month"
	TimeUnitOptional_week   TimeUnitOptional = "week"
)

// UnitAmount defines model for UnitAmount.
type UnitAmount int

// UnitAmountOptional defines model for UnitAmountOptional.
type UnitAmountOptional int

// UnitReferenceTimeStamp defines model for UnitReferenceTimeStamp.
type UnitReferenceTimeStamp string

// CreateFullBitlinkJSONBody defines parameters for CreateFullBitlink.
type CreateFullBitlinkJSONBody FullShorten

// UpdateBitlinkJSONBody defines parameters for UpdateBitlink.
type UpdateBitlinkJSONBody BitlinkBody

// GetMetricsForBitlinkByCitiesParams defines parameters for GetMetricsForBitlinkByCities.
type GetMetricsForBitlinkByCitiesParams struct {

	// A unit of time
	Unit TimeUnit `json:"unit"`

	// An integer representing the time units to query data for. pass -1 to return all units of time.
	Units UnitAmount `json:"units"`

	// The quantity of items to be be returned
	Size *Size `json:"size,omitempty"`

	// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
	UnitReference *UnitReferenceTimeStamp `json:"unit_reference,omitempty"`
}

// GetClicksForBitlinkParams defines parameters for GetClicksForBitlink.
type GetClicksForBitlinkParams struct {

	// A unit of time
	Unit TimeUnit `json:"unit"`

	// An integer representing the time units to query data for. pass -1 to return all units of time.
	Units UnitAmount `json:"units"`

	// The quantity of items to be be returned
	Size *Size `json:"size,omitempty"`

	// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
	UnitReference *UnitReferenceTimeStamp `json:"unit_reference,omitempty"`
}

// GetClicksSummaryForBitlinkParams defines parameters for GetClicksSummaryForBitlink.
type GetClicksSummaryForBitlinkParams struct {

	// A unit of time
	Unit TimeUnit `json:"unit"`

	// An integer representing the time units to query data for. pass -1 to return all units of time.
	Units UnitAmount `json:"units"`

	// The quantity of items to be be returned
	Size *Size `json:"size,omitempty"`

	// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
	UnitReference *UnitReferenceTimeStamp `json:"unit_reference,omitempty"`
}

// GetMetricsForBitlinkByCountriesParams defines parameters for GetMetricsForBitlinkByCountries.
type GetMetricsForBitlinkByCountriesParams struct {

	// A unit of time
	Unit TimeUnit `json:"unit"`

	// An integer representing the time units to query data for. pass -1 to return all units of time.
	Units UnitAmount `json:"units"`

	// The quantity of items to be be returned
	Size *Size `json:"size,omitempty"`

	// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
	UnitReference *UnitReferenceTimeStamp `json:"unit_reference,omitempty"`
}

// GetMetricsForBitlinkByDevicesParams defines parameters for GetMetricsForBitlinkByDevices.
type GetMetricsForBitlinkByDevicesParams struct {

	// A unit of time
	Unit TimeUnit `json:"unit"`

	// An integer representing the time units to query data for. pass -1 to return all units of time.
	Units UnitAmount `json:"units"`

	// The quantity of items to be be returned
	Size *Size `json:"size,omitempty"`

	// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
	UnitReference *UnitReferenceTimeStamp `json:"unit_reference,omitempty"`
}

// GetBitlinkQRCodeParams defines parameters for GetBitlinkQRCode.
type GetBitlinkQRCodeParams struct {

	// A color denoted in hexidecimal RGB format
	Color *Color `json:"color,omitempty"`

	// Removes the Bitly logo from the center of the generated QR image
	ExcludeBitlyLogo *ExcludeBitlyLogo `json:"exclude_bitly_logo,omitempty"`

	// Determines the image format of the returned QR code
	ImageFormat *ImageFormat `json:"image_format,omitempty"`
}

// GetMetricsForBitlinkByReferrersParams defines parameters for GetMetricsForBitlinkByReferrers.
type GetMetricsForBitlinkByReferrersParams struct {

	// A unit of time
	Unit TimeUnit `json:"unit"`

	// An integer representing the time units to query data for. pass -1 to return all units of time.
	Units UnitAmount `json:"units"`

	// The quantity of items to be be returned
	Size *Size `json:"size,omitempty"`

	// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
	UnitReference *UnitReferenceTimeStamp `json:"unit_reference,omitempty"`
}

// GetMetricsForBitlinkByReferrersByDomainsParams defines parameters for GetMetricsForBitlinkByReferrersByDomains.
type GetMetricsForBitlinkByReferrersByDomainsParams struct {

	// A unit of time
	Unit TimeUnit `json:"unit"`

	// An integer representing the time units to query data for. pass -1 to return all units of time.
	Units UnitAmount `json:"units"`

	// The quantity of items to be be returned
	Size *Size `json:"size,omitempty"`

	// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
	UnitReference *UnitReferenceTimeStamp `json:"unit_reference,omitempty"`
}

// GetMetricsForBitlinkByReferringDomainsParams defines parameters for GetMetricsForBitlinkByReferringDomains.
type GetMetricsForBitlinkByReferringDomainsParams struct {

	// A unit of time
	Unit TimeUnit `json:"unit"`

	// An integer representing the time units to query data for. pass -1 to return all units of time.
	Units UnitAmount `json:"units"`

	// The quantity of items to be be returned
	Size *Size `json:"size,omitempty"`

	// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
	UnitReference *UnitReferenceTimeStamp `json:"unit_reference,omitempty"`
}

// ExpandBitlinkJSONBody defines parameters for ExpandBitlink.
type ExpandBitlinkJSONBody ExpandBitlink

// GetBitlinksByGroupParams defines parameters for GetBitlinksByGroup.
type GetBitlinksByGroupParams struct {

	// The quantity of items to be be returned
	Size *Size `json:"size,omitempty"`

	// Integer specifying the numbered result at which to start
	Page *Page `json:"page,omitempty"`

	// Custom keyword to filter on history entries
	Keyword *Keyword `json:"keyword,omitempty"`

	// the value that you would like to search
	Query *Query `json:"query,omitempty"`

	// Timestamp as an integer unix epoch
	CreatedBefore *CreatedBefore `json:"created_before,omitempty"`

	// Timestamp as an integer unix epoch
	CreatedAfter *CreatedAfter `json:"created_after,omitempty"`

	// Timestamp as an integer unix epoch
	ModifiedAfter *ModifiedAfter `json:"modified_after,omitempty"`

	// Whether or not to include archived bitlinks
	Archived *Archived `json:"archived,omitempty"`

	// Filter to only Bitlinks that contain deeplinks
	Deeplinks *Deeplinks `json:"deeplinks,omitempty"`

	// Filter to only Bitlinks that contain deeplinks configured with a custom domain
	DomainDeeplinks *DomainDeeplinks `json:"domain_deeplinks,omitempty"`

	// Filter to return only links for the given campaign GUID, can be provided
	CampaignGuid *FilterCampaignGUID `json:"campaign_guid,omitempty"`

	// Filter to return only links for the given channel GUID, can be provided, overrides all other parameters
	ChannelGuid   *FilterChannelGUID   `json:"channel_guid,omitempty"`
	CustomBitlink *FilterCustomBitlink `json:"custom_bitlink,omitempty"`

	// filter by given tags
	Tags *Tags `json:"tags,omitempty"`

	// Filter by the login of the authenticated user that created the Bitlink
	EncodingLogin *EncodingLogin `json:"encoding_login,omitempty"`
}

// GetSortedBitlinksParams defines parameters for GetSortedBitlinks.
type GetSortedBitlinksParams struct {

	// A unit of time
	Unit *TimeUnitOptional `json:"unit,omitempty"`

	// An integer representing the time units to query data for. pass -1 to return all units of time.
	Units *UnitAmountOptional `json:"units,omitempty"`

	// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
	UnitReference *UnitReferenceTimeStamp `json:"unit_reference,omitempty"`

	// The quantity of items to be be returned
	Size *Size `json:"size,omitempty"`
}

// CreateBitlinkJSONBody defines parameters for CreateBitlink.
type CreateBitlinkJSONBody Shorten

// CreateFullBitlinkJSONRequestBody defines body for CreateFullBitlink for application/json ContentType.
type CreateFullBitlinkJSONRequestBody CreateFullBitlinkJSONBody

// UpdateBitlinkJSONRequestBody defines body for UpdateBitlink for application/json ContentType.
type UpdateBitlinkJSONRequestBody UpdateBitlinkJSONBody

// ExpandBitlinkJSONRequestBody defines body for ExpandBitlink for application/json ContentType.
type ExpandBitlinkJSONRequestBody ExpandBitlinkJSONBody

// CreateBitlinkJSONRequestBody defines body for CreateBitlink for application/json ContentType.
type CreateBitlinkJSONRequestBody CreateBitlinkJSONBody

// Getter for additional properties for HasReferences_References. Returns the specified
// element and whether it was found
func (a HasReferences_References) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for HasReferences_References
func (a *HasReferences_References) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for HasReferences_References to handle AdditionalProperties
func (a *HasReferences_References) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for HasReferences_References to handle AdditionalProperties
func (a HasReferences_References) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateFullBitlink request  with any body
	CreateFullBitlinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFullBitlink(ctx context.Context, body CreateFullBitlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBitlink request
	GetBitlink(ctx context.Context, bitlink Bitlink, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBitlink request  with any body
	UpdateBitlinkWithBody(ctx context.Context, bitlink Bitlink, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBitlink(ctx context.Context, bitlink Bitlink, body UpdateBitlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetricsForBitlinkByCities request
	GetMetricsForBitlinkByCities(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByCitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClicksForBitlink request
	GetClicksForBitlink(ctx context.Context, bitlink Bitlink, params *GetClicksForBitlinkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClicksSummaryForBitlink request
	GetClicksSummaryForBitlink(ctx context.Context, bitlink Bitlink, params *GetClicksSummaryForBitlinkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetricsForBitlinkByCountries request
	GetMetricsForBitlinkByCountries(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByCountriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetricsForBitlinkByDevices request
	GetMetricsForBitlinkByDevices(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBitlinkQRCode request
	GetBitlinkQRCode(ctx context.Context, bitlink Bitlink, params *GetBitlinkQRCodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetricsForBitlinkByReferrers request
	GetMetricsForBitlinkByReferrers(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByReferrersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetricsForBitlinkByReferrersByDomains request
	GetMetricsForBitlinkByReferrersByDomains(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByReferrersByDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetricsForBitlinkByReferringDomains request
	GetMetricsForBitlinkByReferringDomains(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByReferringDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExpandBitlink request  with any body
	ExpandBitlinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExpandBitlink(ctx context.Context, body ExpandBitlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBitlinksByGroup request
	GetBitlinksByGroup(ctx context.Context, groupGuid GroupGUID, params *GetBitlinksByGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSortedBitlinks request
	GetSortedBitlinks(ctx context.Context, groupGuid GroupGUID, sort Sort, params *GetSortedBitlinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBitlink request  with any body
	CreateBitlinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBitlink(ctx context.Context, body CreateBitlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateFullBitlinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFullBitlinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFullBitlink(ctx context.Context, body CreateFullBitlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFullBitlinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBitlink(ctx context.Context, bitlink Bitlink, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBitlinkRequest(c.Server, bitlink)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBitlinkWithBody(ctx context.Context, bitlink Bitlink, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBitlinkRequestWithBody(c.Server, bitlink, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBitlink(ctx context.Context, bitlink Bitlink, body UpdateBitlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBitlinkRequest(c.Server, bitlink, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetricsForBitlinkByCities(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByCitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetricsForBitlinkByCitiesRequest(c.Server, bitlink, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClicksForBitlink(ctx context.Context, bitlink Bitlink, params *GetClicksForBitlinkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClicksForBitlinkRequest(c.Server, bitlink, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClicksSummaryForBitlink(ctx context.Context, bitlink Bitlink, params *GetClicksSummaryForBitlinkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClicksSummaryForBitlinkRequest(c.Server, bitlink, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetricsForBitlinkByCountries(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByCountriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetricsForBitlinkByCountriesRequest(c.Server, bitlink, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetricsForBitlinkByDevices(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetricsForBitlinkByDevicesRequest(c.Server, bitlink, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBitlinkQRCode(ctx context.Context, bitlink Bitlink, params *GetBitlinkQRCodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBitlinkQRCodeRequest(c.Server, bitlink, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetricsForBitlinkByReferrers(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByReferrersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetricsForBitlinkByReferrersRequest(c.Server, bitlink, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetricsForBitlinkByReferrersByDomains(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByReferrersByDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetricsForBitlinkByReferrersByDomainsRequest(c.Server, bitlink, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetricsForBitlinkByReferringDomains(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByReferringDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetricsForBitlinkByReferringDomainsRequest(c.Server, bitlink, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExpandBitlinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExpandBitlinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExpandBitlink(ctx context.Context, body ExpandBitlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExpandBitlinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBitlinksByGroup(ctx context.Context, groupGuid GroupGUID, params *GetBitlinksByGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBitlinksByGroupRequest(c.Server, groupGuid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSortedBitlinks(ctx context.Context, groupGuid GroupGUID, sort Sort, params *GetSortedBitlinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSortedBitlinksRequest(c.Server, groupGuid, sort, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBitlinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBitlinkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBitlink(ctx context.Context, body CreateBitlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBitlinkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateFullBitlinkRequest calls the generic CreateFullBitlink builder with application/json body
func NewCreateFullBitlinkRequest(server string, body CreateFullBitlinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFullBitlinkRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFullBitlinkRequestWithBody generates requests for CreateFullBitlink with any type of body
func NewCreateFullBitlinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bitlinks")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBitlinkRequest generates requests for GetBitlink
func NewGetBitlinkRequest(server string, bitlink Bitlink) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bitlink", runtime.ParamLocationPath, bitlink)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bitlinks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBitlinkRequest calls the generic UpdateBitlink builder with application/json body
func NewUpdateBitlinkRequest(server string, bitlink Bitlink, body UpdateBitlinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBitlinkRequestWithBody(server, bitlink, "application/json", bodyReader)
}

// NewUpdateBitlinkRequestWithBody generates requests for UpdateBitlink with any type of body
func NewUpdateBitlinkRequestWithBody(server string, bitlink Bitlink, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bitlink", runtime.ParamLocationPath, bitlink)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bitlinks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMetricsForBitlinkByCitiesRequest generates requests for GetMetricsForBitlinkByCities
func NewGetMetricsForBitlinkByCitiesRequest(server string, bitlink Bitlink, params *GetMetricsForBitlinkByCitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bitlink", runtime.ParamLocationPath, bitlink)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bitlinks/%s/cities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit", runtime.ParamLocationQuery, params.Unit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "units", runtime.ParamLocationQuery, params.Units); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Size != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UnitReference != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit_reference", runtime.ParamLocationQuery, *params.UnitReference); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClicksForBitlinkRequest generates requests for GetClicksForBitlink
func NewGetClicksForBitlinkRequest(server string, bitlink Bitlink, params *GetClicksForBitlinkParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bitlink", runtime.ParamLocationPath, bitlink)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bitlinks/%s/clicks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit", runtime.ParamLocationQuery, params.Unit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "units", runtime.ParamLocationQuery, params.Units); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Size != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UnitReference != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit_reference", runtime.ParamLocationQuery, *params.UnitReference); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClicksSummaryForBitlinkRequest generates requests for GetClicksSummaryForBitlink
func NewGetClicksSummaryForBitlinkRequest(server string, bitlink Bitlink, params *GetClicksSummaryForBitlinkParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bitlink", runtime.ParamLocationPath, bitlink)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bitlinks/%s/clicks/summary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit", runtime.ParamLocationQuery, params.Unit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "units", runtime.ParamLocationQuery, params.Units); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Size != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UnitReference != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit_reference", runtime.ParamLocationQuery, *params.UnitReference); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetricsForBitlinkByCountriesRequest generates requests for GetMetricsForBitlinkByCountries
func NewGetMetricsForBitlinkByCountriesRequest(server string, bitlink Bitlink, params *GetMetricsForBitlinkByCountriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bitlink", runtime.ParamLocationPath, bitlink)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bitlinks/%s/countries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit", runtime.ParamLocationQuery, params.Unit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "units", runtime.ParamLocationQuery, params.Units); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Size != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UnitReference != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit_reference", runtime.ParamLocationQuery, *params.UnitReference); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetricsForBitlinkByDevicesRequest generates requests for GetMetricsForBitlinkByDevices
func NewGetMetricsForBitlinkByDevicesRequest(server string, bitlink Bitlink, params *GetMetricsForBitlinkByDevicesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bitlink", runtime.ParamLocationPath, bitlink)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bitlinks/%s/devices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit", runtime.ParamLocationQuery, params.Unit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "units", runtime.ParamLocationQuery, params.Units); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Size != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UnitReference != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit_reference", runtime.ParamLocationQuery, *params.UnitReference); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBitlinkQRCodeRequest generates requests for GetBitlinkQRCode
func NewGetBitlinkQRCodeRequest(server string, bitlink Bitlink, params *GetBitlinkQRCodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bitlink", runtime.ParamLocationPath, bitlink)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bitlinks/%s/qr", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Color != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "color", runtime.ParamLocationQuery, *params.Color); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExcludeBitlyLogo != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_bitly_logo", runtime.ParamLocationQuery, *params.ExcludeBitlyLogo); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ImageFormat != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "image_format", runtime.ParamLocationQuery, *params.ImageFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetricsForBitlinkByReferrersRequest generates requests for GetMetricsForBitlinkByReferrers
func NewGetMetricsForBitlinkByReferrersRequest(server string, bitlink Bitlink, params *GetMetricsForBitlinkByReferrersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bitlink", runtime.ParamLocationPath, bitlink)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bitlinks/%s/referrers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit", runtime.ParamLocationQuery, params.Unit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "units", runtime.ParamLocationQuery, params.Units); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Size != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UnitReference != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit_reference", runtime.ParamLocationQuery, *params.UnitReference); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetricsForBitlinkByReferrersByDomainsRequest generates requests for GetMetricsForBitlinkByReferrersByDomains
func NewGetMetricsForBitlinkByReferrersByDomainsRequest(server string, bitlink Bitlink, params *GetMetricsForBitlinkByReferrersByDomainsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bitlink", runtime.ParamLocationPath, bitlink)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bitlinks/%s/referrers_by_domains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit", runtime.ParamLocationQuery, params.Unit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "units", runtime.ParamLocationQuery, params.Units); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Size != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UnitReference != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit_reference", runtime.ParamLocationQuery, *params.UnitReference); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetricsForBitlinkByReferringDomainsRequest generates requests for GetMetricsForBitlinkByReferringDomains
func NewGetMetricsForBitlinkByReferringDomainsRequest(server string, bitlink Bitlink, params *GetMetricsForBitlinkByReferringDomainsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bitlink", runtime.ParamLocationPath, bitlink)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bitlinks/%s/referring_domains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit", runtime.ParamLocationQuery, params.Unit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "units", runtime.ParamLocationQuery, params.Units); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Size != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UnitReference != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit_reference", runtime.ParamLocationQuery, *params.UnitReference); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExpandBitlinkRequest calls the generic ExpandBitlink builder with application/json body
func NewExpandBitlinkRequest(server string, body ExpandBitlinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExpandBitlinkRequestWithBody(server, "application/json", bodyReader)
}

// NewExpandBitlinkRequestWithBody generates requests for ExpandBitlink with any type of body
func NewExpandBitlinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/expand")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBitlinksByGroupRequest generates requests for GetBitlinksByGroup
func NewGetBitlinksByGroupRequest(server string, groupGuid GroupGUID, params *GetBitlinksByGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_guid", runtime.ParamLocationPath, groupGuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/bitlinks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Size != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Keyword != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keyword", runtime.ParamLocationQuery, *params.Keyword); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreatedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ModifiedAfter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modified_after", runtime.ParamLocationQuery, *params.ModifiedAfter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Archived != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archived", runtime.ParamLocationQuery, *params.Archived); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Deeplinks != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deeplinks", runtime.ParamLocationQuery, *params.Deeplinks); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DomainDeeplinks != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain_deeplinks", runtime.ParamLocationQuery, *params.DomainDeeplinks); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CampaignGuid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "campaign_guid", runtime.ParamLocationQuery, *params.CampaignGuid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ChannelGuid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel_guid", runtime.ParamLocationQuery, *params.ChannelGuid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CustomBitlink != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_bitlink", runtime.ParamLocationQuery, *params.CustomBitlink); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Tags != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EncodingLogin != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "encoding_login", runtime.ParamLocationQuery, *params.EncodingLogin); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSortedBitlinksRequest generates requests for GetSortedBitlinks
func NewGetSortedBitlinksRequest(server string, groupGuid GroupGUID, sort Sort, params *GetSortedBitlinksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_guid", runtime.ParamLocationPath, groupGuid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sort", runtime.ParamLocationPath, sort)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/bitlinks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Unit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit", runtime.ParamLocationQuery, *params.Unit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Units != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "units", runtime.ParamLocationQuery, *params.Units); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UnitReference != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit_reference", runtime.ParamLocationQuery, *params.UnitReference); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Size != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBitlinkRequest calls the generic CreateBitlink builder with application/json body
func NewCreateBitlinkRequest(server string, body CreateBitlinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBitlinkRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBitlinkRequestWithBody generates requests for CreateBitlink with any type of body
func NewCreateBitlinkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shorten")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateFullBitlink request  with any body
	CreateFullBitlinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFullBitlinkResponse, error)

	CreateFullBitlinkWithResponse(ctx context.Context, body CreateFullBitlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFullBitlinkResponse, error)

	// GetBitlink request
	GetBitlinkWithResponse(ctx context.Context, bitlink Bitlink, reqEditors ...RequestEditorFn) (*GetBitlinkResponse, error)

	// UpdateBitlink request  with any body
	UpdateBitlinkWithBodyWithResponse(ctx context.Context, bitlink Bitlink, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBitlinkResponse, error)

	UpdateBitlinkWithResponse(ctx context.Context, bitlink Bitlink, body UpdateBitlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBitlinkResponse, error)

	// GetMetricsForBitlinkByCities request
	GetMetricsForBitlinkByCitiesWithResponse(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByCitiesParams, reqEditors ...RequestEditorFn) (*GetMetricsForBitlinkByCitiesResponse, error)

	// GetClicksForBitlink request
	GetClicksForBitlinkWithResponse(ctx context.Context, bitlink Bitlink, params *GetClicksForBitlinkParams, reqEditors ...RequestEditorFn) (*GetClicksForBitlinkResponse, error)

	// GetClicksSummaryForBitlink request
	GetClicksSummaryForBitlinkWithResponse(ctx context.Context, bitlink Bitlink, params *GetClicksSummaryForBitlinkParams, reqEditors ...RequestEditorFn) (*GetClicksSummaryForBitlinkResponse, error)

	// GetMetricsForBitlinkByCountries request
	GetMetricsForBitlinkByCountriesWithResponse(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByCountriesParams, reqEditors ...RequestEditorFn) (*GetMetricsForBitlinkByCountriesResponse, error)

	// GetMetricsForBitlinkByDevices request
	GetMetricsForBitlinkByDevicesWithResponse(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByDevicesParams, reqEditors ...RequestEditorFn) (*GetMetricsForBitlinkByDevicesResponse, error)

	// GetBitlinkQRCode request
	GetBitlinkQRCodeWithResponse(ctx context.Context, bitlink Bitlink, params *GetBitlinkQRCodeParams, reqEditors ...RequestEditorFn) (*GetBitlinkQRCodeResponse, error)

	// GetMetricsForBitlinkByReferrers request
	GetMetricsForBitlinkByReferrersWithResponse(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByReferrersParams, reqEditors ...RequestEditorFn) (*GetMetricsForBitlinkByReferrersResponse, error)

	// GetMetricsForBitlinkByReferrersByDomains request
	GetMetricsForBitlinkByReferrersByDomainsWithResponse(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByReferrersByDomainsParams, reqEditors ...RequestEditorFn) (*GetMetricsForBitlinkByReferrersByDomainsResponse, error)

	// GetMetricsForBitlinkByReferringDomains request
	GetMetricsForBitlinkByReferringDomainsWithResponse(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByReferringDomainsParams, reqEditors ...RequestEditorFn) (*GetMetricsForBitlinkByReferringDomainsResponse, error)

	// ExpandBitlink request  with any body
	ExpandBitlinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExpandBitlinkResponse, error)

	ExpandBitlinkWithResponse(ctx context.Context, body ExpandBitlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*ExpandBitlinkResponse, error)

	// GetBitlinksByGroup request
	GetBitlinksByGroupWithResponse(ctx context.Context, groupGuid GroupGUID, params *GetBitlinksByGroupParams, reqEditors ...RequestEditorFn) (*GetBitlinksByGroupResponse, error)

	// GetSortedBitlinks request
	GetSortedBitlinksWithResponse(ctx context.Context, groupGuid GroupGUID, sort Sort, params *GetSortedBitlinksParams, reqEditors ...RequestEditorFn) (*GetSortedBitlinksResponse, error)

	// CreateBitlink request  with any body
	CreateBitlinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBitlinkResponse, error)

	CreateBitlinkWithResponse(ctx context.Context, body CreateBitlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBitlinkResponse, error)
}

type CreateFullBitlinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BitlinkBody
	JSON400      *BadRequest
	JSON402      *UpgradeRequired
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON417      *ExpectationFailed
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
	JSON503      *TemporarilyUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateFullBitlinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFullBitlinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBitlinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BitlinkBody
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
	JSON503      *TemporarilyUnavailable
}

// Status returns HTTPResponse.Status
func (r GetBitlinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBitlinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBitlinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BitlinkBody
	JSON400      *BadRequest
	JSON402      *UpgradeRequired
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
	JSON503      *TemporarilyUnavailable
}

// Status returns HTTPResponse.Status
func (r UpdateBitlinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBitlinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetricsForBitlinkByCitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CityMetrics
	JSON400      *BadRequest
	JSON402      *UpgradeRequired
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
	JSON503      *TemporarilyUnavailable
}

// Status returns HTTPResponse.Status
func (r GetMetricsForBitlinkByCitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetricsForBitlinkByCitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClicksForBitlinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Clicks
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
	JSON503      *TemporarilyUnavailable
}

// Status returns HTTPResponse.Status
func (r GetClicksForBitlinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClicksForBitlinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClicksSummaryForBitlinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClicksSummary
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
	JSON503      *TemporarilyUnavailable
}

// Status returns HTTPResponse.Status
func (r GetClicksSummaryForBitlinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClicksSummaryForBitlinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetricsForBitlinkByCountriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClickMetrics
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
	JSON503      *TemporarilyUnavailable
}

// Status returns HTTPResponse.Status
func (r GetMetricsForBitlinkByCountriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetricsForBitlinkByCountriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetricsForBitlinkByDevicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeviceMetrics
	JSON400      *BadRequest
	JSON402      *UpgradeRequired
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
	JSON503      *TemporarilyUnavailable
}

// Status returns HTTPResponse.Status
func (r GetMetricsForBitlinkByDevicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetricsForBitlinkByDevicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBitlinkQRCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BitlinkQR
	JSON400      *BadRequest
	JSON402      *UpgradeRequired
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetBitlinkQRCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBitlinkQRCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetricsForBitlinkByReferrersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClickMetrics
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
	JSON503      *TemporarilyUnavailable
}

// Status returns HTTPResponse.Status
func (r GetMetricsForBitlinkByReferrersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetricsForBitlinkByReferrersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetricsForBitlinkByReferrersByDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReferrersByDomains
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
	JSON503      *TemporarilyUnavailable
}

// Status returns HTTPResponse.Status
func (r GetMetricsForBitlinkByReferrersByDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetricsForBitlinkByReferrersByDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetricsForBitlinkByReferringDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClickMetrics
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
	JSON503      *TemporarilyUnavailable
}

// Status returns HTTPResponse.Status
func (r GetMetricsForBitlinkByReferringDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetricsForBitlinkByReferringDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExpandBitlinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExpandedBitlink
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
	JSON503      *TemporarilyUnavailable
}

// Status returns HTTPResponse.Status
func (r ExpandBitlinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExpandBitlinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBitlinksByGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bitlinks
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
	JSON503      *TemporarilyUnavailable
}

// Status returns HTTPResponse.Status
func (r GetBitlinksByGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBitlinksByGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSortedBitlinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SortedLinks
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalError
	JSON503      *TemporarilyUnavailable
}

// Status returns HTTPResponse.Status
func (r GetSortedBitlinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSortedBitlinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBitlinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShortenBitlinkBody
	JSON201      *ShortenBitlinkBody
	JSON400      *BadRequest
	JSON403      *Forbidden
	JSON417      *ExpectationFailed
	JSON422      *UnprocessableEntity
	JSON500      *InternalError
	JSON503      *TemporarilyUnavailable
}

// Status returns HTTPResponse.Status
func (r CreateBitlinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBitlinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateFullBitlinkWithBodyWithResponse request with arbitrary body returning *CreateFullBitlinkResponse
func (c *ClientWithResponses) CreateFullBitlinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFullBitlinkResponse, error) {
	rsp, err := c.CreateFullBitlinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFullBitlinkResponse(rsp)
}

func (c *ClientWithResponses) CreateFullBitlinkWithResponse(ctx context.Context, body CreateFullBitlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFullBitlinkResponse, error) {
	rsp, err := c.CreateFullBitlink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFullBitlinkResponse(rsp)
}

// GetBitlinkWithResponse request returning *GetBitlinkResponse
func (c *ClientWithResponses) GetBitlinkWithResponse(ctx context.Context, bitlink Bitlink, reqEditors ...RequestEditorFn) (*GetBitlinkResponse, error) {
	rsp, err := c.GetBitlink(ctx, bitlink, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBitlinkResponse(rsp)
}

// UpdateBitlinkWithBodyWithResponse request with arbitrary body returning *UpdateBitlinkResponse
func (c *ClientWithResponses) UpdateBitlinkWithBodyWithResponse(ctx context.Context, bitlink Bitlink, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBitlinkResponse, error) {
	rsp, err := c.UpdateBitlinkWithBody(ctx, bitlink, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBitlinkResponse(rsp)
}

func (c *ClientWithResponses) UpdateBitlinkWithResponse(ctx context.Context, bitlink Bitlink, body UpdateBitlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBitlinkResponse, error) {
	rsp, err := c.UpdateBitlink(ctx, bitlink, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBitlinkResponse(rsp)
}

// GetMetricsForBitlinkByCitiesWithResponse request returning *GetMetricsForBitlinkByCitiesResponse
func (c *ClientWithResponses) GetMetricsForBitlinkByCitiesWithResponse(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByCitiesParams, reqEditors ...RequestEditorFn) (*GetMetricsForBitlinkByCitiesResponse, error) {
	rsp, err := c.GetMetricsForBitlinkByCities(ctx, bitlink, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetricsForBitlinkByCitiesResponse(rsp)
}

// GetClicksForBitlinkWithResponse request returning *GetClicksForBitlinkResponse
func (c *ClientWithResponses) GetClicksForBitlinkWithResponse(ctx context.Context, bitlink Bitlink, params *GetClicksForBitlinkParams, reqEditors ...RequestEditorFn) (*GetClicksForBitlinkResponse, error) {
	rsp, err := c.GetClicksForBitlink(ctx, bitlink, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClicksForBitlinkResponse(rsp)
}

// GetClicksSummaryForBitlinkWithResponse request returning *GetClicksSummaryForBitlinkResponse
func (c *ClientWithResponses) GetClicksSummaryForBitlinkWithResponse(ctx context.Context, bitlink Bitlink, params *GetClicksSummaryForBitlinkParams, reqEditors ...RequestEditorFn) (*GetClicksSummaryForBitlinkResponse, error) {
	rsp, err := c.GetClicksSummaryForBitlink(ctx, bitlink, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClicksSummaryForBitlinkResponse(rsp)
}

// GetMetricsForBitlinkByCountriesWithResponse request returning *GetMetricsForBitlinkByCountriesResponse
func (c *ClientWithResponses) GetMetricsForBitlinkByCountriesWithResponse(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByCountriesParams, reqEditors ...RequestEditorFn) (*GetMetricsForBitlinkByCountriesResponse, error) {
	rsp, err := c.GetMetricsForBitlinkByCountries(ctx, bitlink, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetricsForBitlinkByCountriesResponse(rsp)
}

// GetMetricsForBitlinkByDevicesWithResponse request returning *GetMetricsForBitlinkByDevicesResponse
func (c *ClientWithResponses) GetMetricsForBitlinkByDevicesWithResponse(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByDevicesParams, reqEditors ...RequestEditorFn) (*GetMetricsForBitlinkByDevicesResponse, error) {
	rsp, err := c.GetMetricsForBitlinkByDevices(ctx, bitlink, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetricsForBitlinkByDevicesResponse(rsp)
}

// GetBitlinkQRCodeWithResponse request returning *GetBitlinkQRCodeResponse
func (c *ClientWithResponses) GetBitlinkQRCodeWithResponse(ctx context.Context, bitlink Bitlink, params *GetBitlinkQRCodeParams, reqEditors ...RequestEditorFn) (*GetBitlinkQRCodeResponse, error) {
	rsp, err := c.GetBitlinkQRCode(ctx, bitlink, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBitlinkQRCodeResponse(rsp)
}

// GetMetricsForBitlinkByReferrersWithResponse request returning *GetMetricsForBitlinkByReferrersResponse
func (c *ClientWithResponses) GetMetricsForBitlinkByReferrersWithResponse(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByReferrersParams, reqEditors ...RequestEditorFn) (*GetMetricsForBitlinkByReferrersResponse, error) {
	rsp, err := c.GetMetricsForBitlinkByReferrers(ctx, bitlink, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetricsForBitlinkByReferrersResponse(rsp)
}

// GetMetricsForBitlinkByReferrersByDomainsWithResponse request returning *GetMetricsForBitlinkByReferrersByDomainsResponse
func (c *ClientWithResponses) GetMetricsForBitlinkByReferrersByDomainsWithResponse(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByReferrersByDomainsParams, reqEditors ...RequestEditorFn) (*GetMetricsForBitlinkByReferrersByDomainsResponse, error) {
	rsp, err := c.GetMetricsForBitlinkByReferrersByDomains(ctx, bitlink, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetricsForBitlinkByReferrersByDomainsResponse(rsp)
}

// GetMetricsForBitlinkByReferringDomainsWithResponse request returning *GetMetricsForBitlinkByReferringDomainsResponse
func (c *ClientWithResponses) GetMetricsForBitlinkByReferringDomainsWithResponse(ctx context.Context, bitlink Bitlink, params *GetMetricsForBitlinkByReferringDomainsParams, reqEditors ...RequestEditorFn) (*GetMetricsForBitlinkByReferringDomainsResponse, error) {
	rsp, err := c.GetMetricsForBitlinkByReferringDomains(ctx, bitlink, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetricsForBitlinkByReferringDomainsResponse(rsp)
}

// ExpandBitlinkWithBodyWithResponse request with arbitrary body returning *ExpandBitlinkResponse
func (c *ClientWithResponses) ExpandBitlinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExpandBitlinkResponse, error) {
	rsp, err := c.ExpandBitlinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExpandBitlinkResponse(rsp)
}

func (c *ClientWithResponses) ExpandBitlinkWithResponse(ctx context.Context, body ExpandBitlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*ExpandBitlinkResponse, error) {
	rsp, err := c.ExpandBitlink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExpandBitlinkResponse(rsp)
}

// GetBitlinksByGroupWithResponse request returning *GetBitlinksByGroupResponse
func (c *ClientWithResponses) GetBitlinksByGroupWithResponse(ctx context.Context, groupGuid GroupGUID, params *GetBitlinksByGroupParams, reqEditors ...RequestEditorFn) (*GetBitlinksByGroupResponse, error) {
	rsp, err := c.GetBitlinksByGroup(ctx, groupGuid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBitlinksByGroupResponse(rsp)
}

// GetSortedBitlinksWithResponse request returning *GetSortedBitlinksResponse
func (c *ClientWithResponses) GetSortedBitlinksWithResponse(ctx context.Context, groupGuid GroupGUID, sort Sort, params *GetSortedBitlinksParams, reqEditors ...RequestEditorFn) (*GetSortedBitlinksResponse, error) {
	rsp, err := c.GetSortedBitlinks(ctx, groupGuid, sort, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSortedBitlinksResponse(rsp)
}

// CreateBitlinkWithBodyWithResponse request with arbitrary body returning *CreateBitlinkResponse
func (c *ClientWithResponses) CreateBitlinkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBitlinkResponse, error) {
	rsp, err := c.CreateBitlinkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBitlinkResponse(rsp)
}

func (c *ClientWithResponses) CreateBitlinkWithResponse(ctx context.Context, body CreateBitlinkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBitlinkResponse, error) {
	rsp, err := c.CreateBitlink(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBitlinkResponse(rsp)
}

// ParseCreateFullBitlinkResponse parses an HTTP response from a CreateFullBitlinkWithResponse call
func ParseCreateFullBitlinkResponse(rsp *http.Response) (*CreateFullBitlinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateFullBitlinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BitlinkBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest UpgradeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 417:
		var dest ExpectationFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON417 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest TemporarilyUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetBitlinkResponse parses an HTTP response from a GetBitlinkWithResponse call
func ParseGetBitlinkResponse(rsp *http.Response) (*GetBitlinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetBitlinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BitlinkBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest TemporarilyUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateBitlinkResponse parses an HTTP response from a UpdateBitlinkWithResponse call
func ParseUpdateBitlinkResponse(rsp *http.Response) (*UpdateBitlinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateBitlinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BitlinkBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest UpgradeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest TemporarilyUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetMetricsForBitlinkByCitiesResponse parses an HTTP response from a GetMetricsForBitlinkByCitiesWithResponse call
func ParseGetMetricsForBitlinkByCitiesResponse(rsp *http.Response) (*GetMetricsForBitlinkByCitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMetricsForBitlinkByCitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CityMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest UpgradeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest TemporarilyUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetClicksForBitlinkResponse parses an HTTP response from a GetClicksForBitlinkWithResponse call
func ParseGetClicksForBitlinkResponse(rsp *http.Response) (*GetClicksForBitlinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetClicksForBitlinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Clicks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest TemporarilyUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetClicksSummaryForBitlinkResponse parses an HTTP response from a GetClicksSummaryForBitlinkWithResponse call
func ParseGetClicksSummaryForBitlinkResponse(rsp *http.Response) (*GetClicksSummaryForBitlinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetClicksSummaryForBitlinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClicksSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest TemporarilyUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetMetricsForBitlinkByCountriesResponse parses an HTTP response from a GetMetricsForBitlinkByCountriesWithResponse call
func ParseGetMetricsForBitlinkByCountriesResponse(rsp *http.Response) (*GetMetricsForBitlinkByCountriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMetricsForBitlinkByCountriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClickMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest TemporarilyUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetMetricsForBitlinkByDevicesResponse parses an HTTP response from a GetMetricsForBitlinkByDevicesWithResponse call
func ParseGetMetricsForBitlinkByDevicesResponse(rsp *http.Response) (*GetMetricsForBitlinkByDevicesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMetricsForBitlinkByDevicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeviceMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest UpgradeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest TemporarilyUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetBitlinkQRCodeResponse parses an HTTP response from a GetBitlinkQRCodeWithResponse call
func ParseGetBitlinkQRCodeResponse(rsp *http.Response) (*GetBitlinkQRCodeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetBitlinkQRCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BitlinkQR
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest UpgradeRequired
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMetricsForBitlinkByReferrersResponse parses an HTTP response from a GetMetricsForBitlinkByReferrersWithResponse call
func ParseGetMetricsForBitlinkByReferrersResponse(rsp *http.Response) (*GetMetricsForBitlinkByReferrersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMetricsForBitlinkByReferrersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClickMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest TemporarilyUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/csv) unsupported

	}

	return response, nil
}

// ParseGetMetricsForBitlinkByReferrersByDomainsResponse parses an HTTP response from a GetMetricsForBitlinkByReferrersByDomainsWithResponse call
func ParseGetMetricsForBitlinkByReferrersByDomainsResponse(rsp *http.Response) (*GetMetricsForBitlinkByReferrersByDomainsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMetricsForBitlinkByReferrersByDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReferrersByDomains
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest TemporarilyUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetMetricsForBitlinkByReferringDomainsResponse parses an HTTP response from a GetMetricsForBitlinkByReferringDomainsWithResponse call
func ParseGetMetricsForBitlinkByReferringDomainsResponse(rsp *http.Response) (*GetMetricsForBitlinkByReferringDomainsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMetricsForBitlinkByReferringDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClickMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest TemporarilyUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseExpandBitlinkResponse parses an HTTP response from a ExpandBitlinkWithResponse call
func ParseExpandBitlinkResponse(rsp *http.Response) (*ExpandBitlinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ExpandBitlinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExpandedBitlink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest TemporarilyUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetBitlinksByGroupResponse parses an HTTP response from a GetBitlinksByGroupWithResponse call
func ParseGetBitlinksByGroupResponse(rsp *http.Response) (*GetBitlinksByGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetBitlinksByGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bitlinks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest TemporarilyUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetSortedBitlinksResponse parses an HTTP response from a GetSortedBitlinksWithResponse call
func ParseGetSortedBitlinksResponse(rsp *http.Response) (*GetSortedBitlinksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSortedBitlinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SortedLinks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest TemporarilyUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateBitlinkResponse parses an HTTP response from a CreateBitlinkWithResponse call
func ParseCreateBitlinkResponse(rsp *http.Response) (*CreateBitlinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateBitlinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShortenBitlinkBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ShortenBitlinkBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 417:
		var dest ExpectationFailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON417 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest TemporarilyUnavailable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

